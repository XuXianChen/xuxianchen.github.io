[{"title":"散列表浅谈","date":"2020-07-31T12:23:06.000Z","path":"2020/07/31/散列表浅谈/","text":"引言哈希表是一种非常常用的数据结构(KEY-VALUE)，理论上通过键(KEY)进行CRUD操作数据的为时间复杂度位O(1)。大部分的开发语言如Java、Go、C#的库都有实现，还有常见的KV数据库，其核心原理也是哈希表。哈希算法的应用常见更加广泛，如加密、分布式场景数据分片、生成唯一标识、P2P协议验证数据的完整性等。我认为带着问题学习是一种很好的学习方法，下面我对每个知识点以问题的形式展开。 哈希表为啥这么快哈希表是建立在数组上的一种数据结构，数组是一种内存空间连续，并且存储相同数据类型的数据结构，所以当我们知道了一个数组的下标，只需要一次计算（首地址 + 下标值*数组类型字节数）就可以得到对应下标的地址。而哈希表是在数组的基础上的一种数据结构，大致的结构如下:这里假如我们不考虑多个键(key)通过哈希算法得到值相同的情况下,我们将得到的值和数hexo 组进行取模或者与操作，就会得到一个数组的下标。并且我们假设hash(key)得到的下标都不相同。那么当我们存储多个key-value类型的数据时,只需通过一次计算就可以完成查询、插入和删除等操作。但是这里有很多情况都没有考虑，我们下面将一一的进行剖析。 hash冲突问题hash冲突是什么？不同的key通过hash算法计算后，会得到相同的值。从理论上来说，不存在没有hash冲突的算法，为什么呢？我们先来分析一下hash算法具备哪些特征： 相同的key，每次计算出来的value值不会发生改变 不能通过value推导出key值 不同的key计算出来的value不重复(理论上不可能实现), 但是value的长度一样 第三点可以看到，hash算法希望不同的key推导出来的value长度一样，即便是MD5这样的算法，那么根据数学基本常识，通过MD5算法计算出来的value集合最大为：16^32 = 2^128(常见的MD5算法使用16进制，并且最后计算出的value是32个字符)个不同的字符串，然而我们key集合是无穷大的，所以肯定会出现hash冲突情况。 如何解决hash冲突？hash冲突的解决方法目前有两种，一种是开放寻址法，另外一种则是链表法。 开放寻址法就是当发生hash冲突时，使用顺序探测的方式遍历后续节点，如果是插入元素，如果探测到对应的slot为空时，直接将数据进行存储，查询类似，删除操作较为复杂一点，探测到数据是需要删除时，只是将其标记为deleted，并不真正的将其删除。通常顺序的探测效率比较低，可以通过多个hash算法或者跳跃式探测的方式进行优化。如图所示，通过hash算法计算得到下标为3的地址，但是下标为3的slot已经存储数据了，那么我们会去获取下标为4的地址，并且判断该slot有没有存储数据，没有的话就将数据存储到该位置，有就依次进行递归，直到发现空的slot，然后存储。 链表法就是每个slot存储一个链表的head节点的指针，当发生hash冲突时候，在链表的tail节点加入新的元素即可，查询的时候遍历该链表即可。如下图： 一次性扩容性能问题当散列表中的元素过多时，而数组的长度是固定的，这个时候就会出现大量的hash冲突的情况，这个时候如果不对数组进行扩容的话，整个散列的性能就会不断的下降，甚至退化为链表。 这个时候，就需要对数组进行扩容，一般是原来数组的两倍，然而扩容后，同一个数组取模运算或者与运算在基数不同的情况下，得到的结果不一样，所以每次扩容都会出现的大量的数据的搬移，在一些高性能的场景下就会成为性能瓶颈。这个时候我们可以采用渐进式数据迁移，每次新增数据的时候将原散列表的一个数据进行迁移，直到最后全部数据迁移完成，在查询的过程中，先查询新的散列表，如果数据不存在，再查询原来的散列表，其实这就是一种空间换时间的做法，Redis的扩容就是采用渐进式的扩容方式。 哈希算法常用的应用场景 安全加密场景，如果有同学对接过微信支付或者支付宝支付，就知道数据传输过程中需要使用MD5生成数字签名sign，微信服务端会对该sign进行校验，校验通过才能进行下一步操作 散列表，场景的如Java里面的HashMap&lt;&gt;(),Go语言map关键字实现等 校验数据的完整性。如场景的P2P协议，常规的协议客户端都是从中心服务器获取数据，而P2P协议是一种去中心化的协议，每个客户端下载文件后，那么他自己就会成为一个服务器供别人下载文件。在这样的场景下，肯定会出现安全性问题，因为任何一个人都可以修改文件。在这种情况下，P2P协议需要使用一个种子文件，该文件存储需要下载的文件的分片的hash值，每次下载完的文件分片都需要和该hash进行对比，如果匹配就可以认为该文件没有被破坏，否则就从其他节点下载该片段。 唯一标识。如何识别图片的唯一性，我们可以对图片序列化后的一部分字节进行hash运算，作为该图片的唯一标识。 分布式场景，如负载均衡算法，数据分片等。通过对用户的id或者ip进行hash运算并对机器节点数量取模运算，可以让一个用户的请求固定的落到一个服务接点上，这样我们只需要缓存一份数据，而不是每个节点都需要缓存，可以节约内存开销，如session缓存。但是这里同样会遇到一个问题就是数组扩容时，需要进行大量的数据搬运，通过渐进式迁移数据会需要浪费大量的空间，在缓存或者数据分片的场景下显然是不合适的，这个时候我们就会有一致性hash算法解决，每次扩容都只搬运少量的数据。 一致性hash算法如何理解我们先来看看什么是一致性hash算法，根据维基百科定义如下： In computer science, consistent hashing is a special kind of hashing such that when a hash table is resized, only n/m keys need to be remapped on average where n is the number of keys and m is the number of slots. 翻译大概意思就是，一致性hash是一种特殊的hash算法，当哈希表表进行扩容时，一致性hash算法只需要移动n/m个元素的位置，其中n代表hash表key的数量，m代表数组长度。 简单来说，就是如果你设计的hash算法的值范围是0100，即无论key是什么，hash(key)得到的值都在0100以内，这个时候，如果数组长度为10，那么我们可以hash(key)值为010，1120，2130…等均匀的落到下标为0，1，2..的slot中，当新增一个数组节点时，可以将hash值为09，1018..均匀的落到下标为：0, 1, 2..10的节点上，这样你可以看到hash值为09这一段数据就没有发生搬运，核心思想就是这样，当然工业上还有使用环这样的方式更加巧妙的进行，总之其目的就是在数组扩容时，尽量减少数据的搬运。"},{"title":"架构设计浅谈","date":"2020-07-30T14:47:32.000Z","path":"2020/07/30/架构设计浅谈/","text":"前言可以说，任何软件都有一个架构，一般大型互联网公司还会专门设有架构师的职位。那么我们有没有想过这个问题，架构到底是什么？为什么我们需要去做架构设计？如果没有架构设计的话我们软件开发与维护的过程中会遇到什么问题？要回答这些问题，我们可以在下面的文章中慢慢的讲述。 首先，软件架构到底是指什么？通常，我们去阅读一本书的时候，我们首先会去翻一翻这本书的目录结构，看一下这本书到底讲的是什么，每个章节作者想表达的主要意思是什么，通过阅读目录让我们对整本书有了一个系统性的认识。软件架构和书本的目录有点类似，但是又有明显的区别。我们可以认为软件架构就是软件或者系统的一个顶层结构。在这里有一个关键点，整个系统的架构会由子系统、模块、组件等元素组成，并且这些元素之间需要互相的合作，从而组成一个新的系统，能完成他们任何一个元素都无法完成的事情。这里顺便讲一下系统、子系统、模块和组件的关联和区别，一个大型系统一般都是由一些的子系统组成的，如现在流行的微服务架构，一个主流的电商的微服务架构的系统，通常都会由用户子系统、订单子系统、商品子系统、库存子系统、支付子系统等构成。而一个子系统通常又会由模块或者组件构成。模块和组件表达的维度不同，模块强调的是子系统如何进行拆分的，而组件侧重的维度则是复用功能。 其次，架构设计的目的是什么？当问到为什么我们开发之前需要做系统设计或者架构设计，有些同学会抱怨道：“没办法呀，公司或者团队的规范就是这样子啦，不做没办法哇！”。还有些同学会说，我就没有做过系统设计，需求评审完我上来就咔咔咔的写代码，不也完成领导交代的任务了吗，要那玩意儿干啥。当然，简单的需求确实没有什么必要做系统设计，但是当我们面对一个业务非常复杂的财务系统，高并发，海量数据的系统的时候，不提前做系统设计和分析，那么就会面临任务如何合理的分配，如何做到通用功能重用，系统难以维护等等一些的问题。通常，通过软件架构的设计，我们主要的目的可以分为如下几类： 复杂性。将一个复杂的系统进行拆分子系统，子系统又可以拆分成模块和组件。每个模块和组件内部只负责它自己的功能，并且对外提供接口，其他的模块 或者组件完全不需要理解它内部是如何实现的。 扩展性。在架构设计的时候，如何考虑到业务的发展，预留一些扩展点的设计，有助于系统的扩展。同时，我们在将系统进行拆分后，组装的过程中，需要考虑尽量的低耦合（软件设计最基本的原则，高内聚，低耦合）。在设计模式或者软件设计中，组件、模块和类之间交互的方式有：继承，实现，组合，依赖等。我们在做软件设计过程中，如果尽量的使用组合，依赖等耦合比较小的方式，能提高软件的扩展性。目前流行的Go语言设计中，就已经摒弃了继承这种强依赖特性。 复用性。软件架构设计过程中，可以将一些通用的一些功能提取出来，做到通用，这个还是比较容易理解的。 高性能。软件架构设计有利于设计出高性能的系统，通过将系统分解。可以针对不同的系统，定制化的分配资源。如一些子系统IO比较密集，可以分配更大的磁盘，并且增加缓存。而一些计算密集型的系统，可以分配性能更优的CPU。 高可用。高可用也比较容易理解。All in one的系统全部部署到一个web服务器上，支持的并发数量有限，并且节点挂掉，整个服务不可用，就算是多节点部署，如果数据库出一点问题，整个服务也不用。而主流的微服务架构采用多节点，多数据的方式部署，即便是一个服务挂掉了，其他服务仍然是可用状态。 架构设计常用的一些套路 深入理解需求，识别出业务的复杂度的点，而不是生搬硬套主流的系统架构。如一个电商系统中的商品系统和营销系统，商品系统核心点需要支持海量的用户快速的访问，所以设计过程中，肯定需要考虑高并发、降低延时，这个时候加入缓存是一个比较好的思路。而营销系统需要满足运营不断变化各种营销策略，所以易扩展是最核心的点，这个时候考虑规则引擎就是比较合理的。而如果两个系统采用相同的套路，显然是行不通的。 分解：场景的一些名词如：垂直拆分、水平拆分、分层、分治、去中心化、分片等，这里将其统称为分解。分解是一个逐步的过程，将一个大的系统逐步分成各个小的系统，然后采用分而治之的方式。 合并：将各个组件、系统进行组装，就像平高玩具一样，将一些零件最后进行组装，形成一个新的系统。常见的组转方式有：继承、组合、依赖、关联等，这里的一个标准就是尽量的使用耦合较低的组合方式。 抽象：通过向上的抽象，总结出通用的概念模型，设计过程中尽量面向抽象而不是实现。 简单分析一波Mysql的逻辑架构 采用分层的架构设计，每一层内部又进行分层 每一层又被拆分成不同的子系统和组件，提高系统的复用性，并且简化系统的开发 服务层不直接调用存储引擎层，而是依赖接口的方式（数据CRUD的抽象），将具体的实现进行隐藏，底层的存储引擎可以根据业务进行调整，这也是Mysql特别灵活的原因 各个组件之间的关系也不是强耦合的关系，而是依赖的方式 结语最后，知之非难，行之不易，要学会架构设计还需要不断的实践和演练，优秀的架构师不是学出来的，而是实践演练出来的，一个优秀的的系统架构一般也不是一下就设计出来的，通常都是不断的演练，不断的修改形成的，这也是为什么很多大型的架构分享都是XX架构的演进，而不是XX架构的设计。咳咳，连淘宝最初都是采用外购的呀～"},{"title":"JAVA队列同步器浅谈","date":"2019-12-15T00:03:15.000Z","path":"2019/12/15/JAVA并发队列同步器浅谈/","text":"同步器到底是什么？队列同步器AbstractQueuedSynchronizer（简称AQS）是并发包的作者Doug Lea开发的一个同步框架，可以用来构建锁和其他同步组件，并发包下很多常用的类核心都是使用AQS实现的，所以掌握AQS对于我们学习并发编程尤为重要。 其核心为一个volatile修饰的state变量（同步状态）和FIFO的队列组成，通过获取和设置同步状态来判断是否可以占有资源，而队列可以认为是一个等待队列，获取资源失败的线程都会加入到这个队列中去，当Runnable状态的线程执行完毕释放资源的时候，队列中的一个线程会被唤醒。 同步器接口实现简单分析：AQS采用了模版方法设计模式，Doug Lea将一些通用的操作封装成了模版方法，所以使用者需要继承AQS并实现AQS指定的方法，然后调用同步器提供的模版方法方法，而这些模版方法会反过来调用重写的方法。AQS提供的模版方法大体分为三类：独占式的获取/释放同步状态、共享式的获取/释放同步状态、获取等待队列中等待线上的情况。下面是AQS部分代码： 123456789101112131415161718192021222324// 独占式的获取同步状态public final void acquire(int arg)&#123;....&#125;// 独占式的获取同步状态: 响应线程中断public final void acquireInterruptibly(int arg)&#123;...&#125;// 独占式的获取同步状态: 可以设置超时时间public final boolean tryAcquireNanos(int arg, long nanosTimeout)&#123;...&#125;// 独占式的释放同步状态public final boolean release(int arg) &#123;...&#125;//-----------------------------------------------------------------------// 共享的获取同步状态public final void acquireShared(int arg) &#123;...&#125;// 共享的获取同步状态：响应线程中断public final void acquireSharedInterruptibly(int arg) &#123;...&#125;// 共享的获取同步状态：可以设置超时时间public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)&#123;...&#125;// 共享的释放同步状态public final boolean releaseShared(int arg) &#123;...&#125;//------------------------------------------------------------------------// 获取等待的线程public final Collection&lt;Thread&gt; getWaitingThreads(ConditionObject condition)&#123;...&#125; 同步器核心原理分析同步队列所谓的同步队列为一个FIFO的队列，获得同步状态的节点将自己设置为Head节点，后续未获得同步状态的节点通过CAS将自己设置为Tail节点，同步队列的节点代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849static final class Node &#123; /* 标记当前节点为共享模式 */ static final Node SHARED = new Node(); /* 标记当前节点为独占模式（默认） */ static final Node EXCLUSIVE = null; /* 节点代表的线程等待超时或者被中断，需要被取消 */ static final int CANCELLED = 1; /* 节点代表的线程可以被唤醒 */ static final int SIGNAL = -1; /* 节点代表的线程处于等待状态 */ static final int CONDITION = -2; /* 共享模式下的等待状态会被传播下去 */ static final int PROPAGATE = -3; /* 等待状态 */ volatile int waitStatus; /* 前驱节点 */ volatile Node prev; /* 后续节点 */ volatile Node next; /* 当前线程代表的线程 */ volatile Thread thread; /* 等待队列中的后续节点 */ Node nextWaiter; final boolean isShared() &#123; return nextWaiter == SHARED; &#125; final Node predecessor() throws NullPointerException &#123; Node p = prev; if (p == null) throw new NullPointerException(); else return p; &#125; Node() &#123; // Used to establish initial head or SHARED marker &#125; Node(Thread thread, Node mode) &#123; // Used by addWaiter this.nextWaiter = mode; this.thread = thread; &#125; Node(Thread thread, int waitStatus) &#123; // Used by Condition this.waitStatus = waitStatus; this.thread = thread; &#125; &#125; 独占式的获取/释放同步状态独占是的获取同步状态主要逻辑为：首先尝试获取同步状态，如果失败，创建一个node，并将该node加入的queue的尾部，同时设置该节点以自旋的方式判断自己是否可以获取同步状态 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 独占式的获取同步状态public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125;private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; enq(node); return node;&#125; private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 解释：如果获取同步状态失败，则创建一个节点并将其加入到队列的尾部（由于加入到尾部的过程可能存在并发，这里采用循环CAS方式来进行设置），最后的acquireQueued（）方法则让该节点通过自旋的方式来判断自己前驱节点是否为head（p == head &amp;&amp; tryAcquire(arg)），如果是则尝试获取同步状态，成功后将自己设置为head 释放独占状态逻辑为：尝试释放同步状态，如果成功则唤醒后续节点 123456789public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false; &#125; 共享式的同步状态的获取/释放同步状态共享式的同步状态的获取表示一个时刻可以有多个线程获取同步状态 123456789101112131415161718192021222324252627private void doAcquireShared(int arg) &#123; final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; 从代码中可以看出，只要state返回值大于或者等于0，即表示可以获取同步状态，释放和独占式释放没有什么区别 总结AQS的核心为： 1、采用模版方法设计模式，核心的队列构建、获取/释放同步状态等由类自身实现，只将一些可变的操作交给锁或者同步组件的实现者 2、volatile修饰的state保证同步状态被修改后可见 3、使用FIFO的同步队列来保存未获取到同步状态的线程，并在条件满足时唤醒他们"}]